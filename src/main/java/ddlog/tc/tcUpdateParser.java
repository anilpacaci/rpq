// Automatically generated by the DDlog compiler.
package ddlog.tc;
import ddlogapi.DDlogAPI;
import ddlogapi.DDlogCommand;
import ddlogapi.DDlogException;
import com.google.flatbuffers.*;
public class tcUpdateParser
{
    public tcUpdateParser(java.nio.ByteBuffer bb) {
        this.commands = ddlog.__tc.__Commands.getRootAs__Commands(bb);
    }
    private ddlog.__tc.__Commands commands;
    public static byte[] byteBufferToArray(java.nio.ByteBuffer buf) {
        byte[] arr = new byte[buf.remaining()];
        buf.get(arr);
        return arr;
    }
    public int numCommands() {
        return this.commands.commandsLength();
    }
    public CommandReader command(int i){
        if (i >= this.numCommands() || i < 0) {
            throw new IndexOutOfBoundsException("Command index " + i + " out of bounds");
        }
        return new CommandReader(this.commands.commands(i));
    }
    public static void transactionCommitDumpChanges(DDlogAPI hddlog,
            java.util.function.Consumer<DDlogCommand<Object>> callback) throws DDlogException{
        DDlogAPI.FlatBufDescr fb = new DDlogAPI.FlatBufDescr();
        hddlog.transactionCommitDumpChangesToFlatbuf(fb);
        try {
            tcUpdateParser parser = new tcUpdateParser(fb.buf);
            int ncmds = parser.numCommands();
            for (int i = 0; i < ncmds; i++) {
                callback.accept(parser.command(i));
            }
        } finally { hddlog.flatbufFree(fb); }
    }
}